# GO design

Go 语言是编译型的，并发的，有gc的以及静态类型的语言。

Go是为了应对大型软件系统而设计出来的，更关注工程而非学术。

Go想解决的问题：

1. 编译慢
2. 依赖的控制
3. 语言各种编译标准
4. 语言的易理解性
5. 重复的工作
6. 更新困难
7. 版本问题
8. 自动化工具缺失
9. 跨语言编译

c++的头文件依赖太过臃肿且复杂（一个准确的依赖可以节省40%的大小），编译的速度非常慢，对于Google甚至需要有一个分布式的编译系统。

一个符合工程的设计：

- 必须可以支撑大量的依赖，大规模的运行
- c-like最好，因为大家比较熟悉
- 需要有一些更现代的特性，比如并发

## Go的依赖

go如果导入未使用的包，编译时会直接报错而不是warning，这使得文件的依赖都很精准，编译也更快。

被依赖的文件优先被编译，同时生成的文件会包含所有影响自身的类型信息，另外编译的时候只会打开一个文件（？ TODO）

go不允许循环导入，编译器和链接器都会进行检查。

go认为依赖关系的整洁比代码重用更加重要，所以复制一些代码比为了一个小功能而引入一个大库要好。

细粒度的依赖有什么问题吗？ 比如import '.../.../.../...' from xxx import xxx 之类的语法也会导致依赖臃肿吗？

## Go的包

go可以导入远程包，先用go get来获取，并通过url来标识

这样的特性可以很好地链接开源社区，但总感觉有点怪怪的。

没有一个统一的版本管理站点，镜像啥的也不好做，就在包的稳定性上有点信任风险吧

## 语法

go有类型推导，比较好用

go不支持默认的函数参数，因为默认的函数参数会导致程序员容易设计出有缺陷的API（提供更多的api）

## 命名

通过首字母大小写来确定方法是public 还是 private

## 语义

感觉go简化了很多语义来达到工程语言的目标

## 并发和gc

这边主要讲了为什么要用gc以及提供并发，并发和gc的原理没有说，todo：

### go并发的原理

[TODO]

### go的gc原理

[TODO]

## oop

go支持组合不支持继承。
组合和继承各有各的优缺点，感觉go之所以直接ban掉一个，还是想简化编码，用统一的规则提高可读性

## 错误处理

go没有异常，而且强制进行错误处理，感觉是一个好的设计

## 工具

go fmt真的太好了
